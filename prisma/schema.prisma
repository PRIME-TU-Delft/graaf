
generator client {
	provider = "prisma-client-js"
}

datasource db {
	provider = "postgresql"
	url      = env("DATABASE_URL")
}

enum UserRole {
	USER
	ADMIN
}

model User {
	id					String		@id @default(cuid())
	role				UserRole	@default(USER)
	nickname			String?
	firstName			String?
	lastName			String?
	email				String		@unique
	emailVerified		DateTime?
	image				String?

	accounts			Account[]
	sessions			Session[]

	program_editors		Program[]	@relation("EditorRelation")
	program_admins		Program[]	@relation("AdminRelation")
	course_editors		Course[]	@relation("EditorRelation")
	course_admins		Course[]	@relation("AdminRelation")

	createdAt			DateTime	@default(now())
	updatedAt			DateTime	@updatedAt
}

model Account {
	userId				String
	type				String
	provider			String
	providerAccountId	String
	refresh_token		String?
	access_token		String?
	expires_at			Int?
	token_type			String?
	scope				String?
	id_token			String?
	session_state		String?

	createdAt			DateTime	@default(now())
	updatedAt			DateTime	@updatedAt

	user				User		@relation(fields: [userId], references: [id], onDelete: Cascade)

	@@id([provider, providerAccountId])
}

model Session {
	sessionToken		String		@unique
	userId				String
	expires				DateTime
	user				User		@relation(fields: [userId], references: [id], onDelete: Cascade)

	createdAt			DateTime	@default(now())
	updatedAt			DateTime	@updatedAt
}

model VerificationToken {
	identifier			String
	token				String
	expires				DateTime

	@@id([identifier, token])
}

model Program {
	id					Int			@id @default(autoincrement())
	name				String

	createdAt			DateTime	@default(now())
	updatedAt			DateTime	@updatedAt

	// Relations
	// Program <*--*> Course
	courses				Course[]
	editors				User[]		@relation("EditorRelation")
	admins				User[]		@relation("AdminRelation")
}

enum CourseType {
	COURSE
	SANDBOX
}

model Course {
	code				String		@id @unique
	type				CourseType	@default(COURSE)
	name				String
	isArchived			Boolean		@default(false)

	createdAt			DateTime	@default(now())
	updatedAt			DateTime	@updatedAt

	// Relations
	// Course <*--*> Program
	// Course <---*> Graph
	programs			Program[]
	graphs				Graph[]
	editors				User[]		@relation("EditorRelation")
	admins				User[]		@relation("AdminRelation")
}

model Graph {
	id					Int			@id @default(autoincrement())
	name				String
	courseId			String

	createdAt			DateTime	@default(now())
	updatedAt			DateTime	@updatedAt

	// Relations
	// Graph <*---> Course
	course				Course		@relation(fields: [courseId], references: [code])
	domains				Domain[]
	subjects			Subject[]
	lectures			Lecture[]

	@@unique([courseId, name])
}

enum DomainStyle {
	PROSPEROUS_RED
	ENERGIZING_ORANGE
	SUNNY_YELLOW
	ELECTRIC_GREEN
	CONFIDENT_TURQUOISE
	MYSTERIOUS_BLUE
	MAJESTIC_PURPLE
	POWERFUL_PINK
	NEUTRAL_GRAY
	SERIOUS_BROWN
}

model Domain {
	id					Int			@id @default(autoincrement())
	name				String
	style				DomainStyle?
	order 				Int	// Domains is a SORTABLE ARRAY this order makes sure this order is perserved on reload
	x 					Int			@default(0)
	y 					Int			@default(0)
	graphId				Int

	createdAt			DateTime	@default(now())
	updatedAt			DateTime	@updatedAt

	// Relations
	// Domain <*---> Graph
	// Domain <---*> Subject
	graph				Graph		@relation(fields: [graphId], references: [id], onDelete: Cascade)
	subjects			Subject[]
	sourceDomains		Domain[]	@relation("DomainRelation")
	targetDomains		Domain[]	@relation("DomainRelation")

	@@unique([name, graphId])
}

model Subject {
	id					Int			@id @default(autoincrement())
	name				String		@default("")
	order				Int // Subjects is a SORTABLE ARRAY this order makes sure this order is perserved on reload
	x					Int			@default(0)
	y					Int			@default(0)
	graphId				Int
	domainId			Int?

	createdAt			DateTime	@default(now())
	updatedAt			DateTime	@updatedAt

	// Relations
	// Subject <*---> Graph
	// Subject <*---> Domain
	// Subject <*--*> Lecture
	graph				Graph		@relation(fields: [graphId], references: [id], onDelete: Cascade)
	domain				Domain?		@relation(fields: [domainId], references: [id])
	lectures			Lecture[]
	sourceSubjects		Subject[]	@relation("SubjectRelation")
	targetSubjects		Subject[]	@relation("SubjectRelation")

	@@unique([name, domainId])
}

model Lecture {
	id					Int			@id @default(autoincrement())
	name				String		@default("")
	order				Int
	graphId				Int

	createdAt			DateTime	@default(now())
	updatedAt			DateTime	@updatedAt

	// Relations
	// Lecture <*---> Graph
	// Lecture <*--*> Subject
	graph				Graph		@relation(fields: [graphId], references: [id], onDelete: Cascade)
	subjects			Subject[]

	@@unique([name, graphId])
}
